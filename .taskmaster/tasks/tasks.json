{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Complete Task Master MCP Integration",
        "description": "Finalize the integration of Task Master MCP server into KODAN development workflow",
        "status": "done",
        "priority": "high",
        "dependencies": [],
        "details": "Set up Task Master MCP server to run locally and integrate with KODAN's existing API infrastructure. Support for OpenRouter and Jina API keys. Compatible with Cursor IDE MCP protocol.",
        "testStrategy": "Verify task creation and management via chat interface and Cursor IDE functionality"
      },
      {
        "id": 2,
        "title": "Implement n8n Workflow Integration",
        "description": "Create MCP bridge between KODAN and n8n for workflow automation",
        "status": "done",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "details": "Develop integration hooks between Task Master MCP and n8n workflow automation platform.",
        "testStrategy": "Test automated task creation and status updates through n8n workflows"
      },
      {
        "id": 3,
        "title": "Enhance Telegram Bot with Task Management",
        "description": "Add Task Master capabilities to KODAN Telegram bot for remote task management",
        "status": "deferred",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "details": "Integrate Task Master MCP tools with existing Telegram bot infrastructure.",
        "testStrategy": "Test task creation, status updates, and queries via Telegram commands"
      },
      {
        "id": 4,
        "title": "Deploy MCP Server to VPS",
        "description": "Set up Task Master MCP server on Hostinger VPS for always-available access",
        "status": "done",
        "priority": "low",
        "dependencies": [
          1
        ],
        "details": "Docker container deployment on Hostinger VPS with integration to existing services.",
        "testStrategy": "Verify remote access and functionality from multiple clients"
      },
      {
        "id": 5,
        "title": "Configure Development Workflow",
        "description": "Set up task-driven development workflow using Task Master",
        "status": "done",
        "priority": "high",
        "dependencies": [
          1
        ],
        "details": "Implement iterative task breakdown, progress tracking, and integration with Git workflow.",
        "testStrategy": "Complete a full development cycle using Task Master methodology"
      },
      {
        "id": 6,
        "title": "Enhance KODAN Web Interface",
        "description": "Add Task Master UI components to KODAN web interface",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          1,
          5
        ],
        "details": "Integrate Kanban board and task management UI into existing KODAN web interface.",
        "testStrategy": "Verify UI functionality and user experience"
      },
      {
        "id": 7,
        "title": "Fix HTTPS SSL Configuration",
        "description": "Resolve SSL certificate issues for kodan.space and n8n.kodan.space",
        "status": "done",
        "priority": "medium",
        "dependencies": [],
        "details": "Configure proper SSL certificates for secure HTTPS access to KODAN services.",
        "testStrategy": "Verify HTTPS access to all KODAN services"
      },
      {
        "id": 8,
        "title": "Codebase Cleanup",
        "description": "Remove temporary scripts, logs, and unnecessary files from development",
        "details": "Clean up: deployment scripts, log files, test scripts, debugging files, SSH keys, and organize project structure",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create Cursor Rules",
        "description": "Establish development standards and coding conventions",
        "details": "Create .cursor/rules file with KODAN-specific development guidelines, code style, and best practices",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "KODAN Feature Audit",
        "description": "Comprehensive audit of current KODAN/Khoj capabilities",
        "details": "Document all existing features: chat, research, agents, automation, file processing, integrations",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Project Roadmap",
        "description": "Define strategic direction for KODAN development",
        "details": "Outline future features, integration plans, UI enhancements, and development priorities",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Enhanced Telegram Integration",
        "description": "Enhance the Telegram bot's functionality based on the feature audit. This includes implementing slash commands (e.g., /research, /agent), allowing users to select a conversation thread, enabling file uploads, and allowing users to switch between AI agents directly within the chat.",
        "status": "deferred",
        "dependencies": [],
        "priority": "low",
        "details": "Based on a feature audit, the following enhancements are required:\n1.  **Slash Commands:** Implement a robust handler for slash commands, including `/research` to activate research tools and `/agent` to manage AI agents.\n2.  **Conversation Selection:** Allow users to list, select, and switch between different conversation threads.\n3.  **File Uploads:** Enable the bot to receive and process file uploads from users.\n4.  **Agent Switching:** Provide a mechanism for users to switch the active AI agent directly within a chat session.",
        "testStrategy": "1.  Verify that all new slash commands (`/research`, `/agent`) are recognized and trigger the correct actions.\n2.  Test the conversation selection flow: ensure users can list their conversations and successfully switch to a different one.\n3.  Test file uploads with various file types to ensure they are received and handled correctly.\n4.  Confirm that switching AI agents via the `/agent` command changes the active model for subsequent messages in the chat.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Implement a slash command handler framework for the Telegram bot.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Implement the `/research` command to integrate with research tools.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Implement the `/agent` command to allow users to list and switch AI agents.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Develop the conversation thread selection and management feature.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Add functionality to handle and process file uploads from users.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Set Up CI/CD Pipeline for Automated Build, Test, and Deployment",
        "description": "Establish a CI/CD pipeline to automate the building of Docker images, running of tests, and deployment to the VPS. This will be triggered by a 'git push' to a designated branch, replacing the current manual deployment process.",
        "details": "The primary goal is to create a fully automated workflow from code commit to deployment using a platform like GitHub Actions. The pipeline should be configured to trigger on a `git push` to the `main` or a new `deploy` branch. Key steps include: 1. Checking out the latest code. 2. Running linters and static analysis based on the rules from Task 9. 3. Building a new Docker image for the application. 4. Running the automated test suite against the new build. 5. If tests pass, pushing the Docker image to a container registry (e.g., GitHub Container Registry). 6. Securely connecting to the production VPS (from Task 4) to pull the new image and restart the service, likely via Dokploy webhooks or SSH commands. All credentials and keys must be stored as encrypted secrets in the CI/CD platform.",
        "testStrategy": "1. Create a feature branch, make a minor code change, and open a pull request against the `main` branch. 2. Verify that the CI pipeline triggers, runs all checks and tests, but does not deploy. 3. Merge the pull request into `main`. 4. Confirm that this merge event triggers the full pipeline, including the deployment step. 5. Monitor the pipeline logs to ensure each stage completes successfully. 6. Access the live application URL and verify that the new change is active and functional. 7. Intentionally push a change that fails a test to confirm the pipeline fails and prevents deployment.",
        "status": "pending",
        "dependencies": [
          4,
          5,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Fix Broken UI Branding",
        "description": "Diagnose and resolve the issue causing Aletheia brand logos to fail to load on the live server. This bug results in 404 errors for SVG assets and negatively impacts the user interface's branding.",
        "details": "The primary goal is to identify why SVG logo assets are not being served correctly on the live environment. Start by using browser developer tools to inspect the network requests and confirm the exact paths that are returning 404 errors. Investigate the Next.js application's static file handling; verify that the logo assets are located in the `/public` directory. Review the application code to ensure the image source paths are correctly referenced (e.g., `/logo.svg`). Pay close attention to the `Dockerfile` to ensure the `public` directory is being correctly copied into the production image during the build process. A missing or incorrect `COPY ./public ./public` instruction is a likely culprit.",
        "testStrategy": "1. After deploying the fix, perform a hard refresh (clearing cache) on the web application in a browser. 2. Visually confirm that the Aletheia logos now appear correctly in all expected locations in the UI. 3. Open the browser's developer tools, go to the 'Network' tab, and reload the page. 4. Filter the network requests for `.svg` files and verify that the logo assets now load with a `200 OK` status code. 5. Confirm that no 404 errors related to image or brand assets are present in the console or network log.",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Fix Email Login Rate Limiting",
        "description": "The server logs show the user is being immediately rate-limited ('429 Too Many Requests') when attempting to log in via email. This task is to correct the configuration to allow for a reasonable number of login attempts.",
        "details": "Investigate the rate-limiting logic in `src/khoj/routers/helpers.py` and `src/khoj/routers/auth.py`. The current implementation incorrectly triggers a '429 Too Many Requests' error on the first login attempt. Analyze the rate-limiter's configuration (e.g., token bucket size, refill rate) and the key used to identify clients. Adjust the parameters to permit a reasonable number of login attempts (e.g., 5-10 attempts per minute) before enforcement. Ensure the rate-limiting is applied on a per-user or per-IP basis, not globally.",
        "testStrategy": "1. Before applying the fix, write a test that replicates the bug: an initial login attempt should fail with a 429 status code. 2. After applying the fix, confirm the initial test now passes, allowing a successful login. 3. Write a new test to verify that multiple failed login attempts (e.g., with a wrong password) up to the new limit return a standard authentication error, not a 429. 4. Write a final test to confirm that exceeding the configured limit of failed attempts correctly triggers the '429 Too Many Requests' error. 5. Monitor server logs during testing to ensure the rate-limiter behaves as expected.",
        "status": "done",
        "dependencies": [
          9
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Resume Obsidian Integration",
        "description": "Begin developing the 'second brain' Obsidian vault. This involves actively using the existing integration to research and document best practices for organizing knowledge, leveraging the vector database, and refining the RAG process.",
        "status": "in-progress",
        "dependencies": [
          14,
          15
        ],
        "priority": "medium",
        "details": "Now that the Obsidian integration is functional, the focus shifts to actively building out the knowledge base. This task involves using the connected Obsidian vault as a 'second brain' for the Aletheia project. Key activities include: 1. Researching and documenting best practices for knowledge organization systems (like Zettelkasten or PARA) suitable for our project. 2. Populating the vault with high-quality, structured notes on topics relevant to Aletheia's development, including AI research, vector databases, and RAG optimization techniques. 3. Actively using the system to test how new content is indexed and retrieved. 4. Refining the RAG process based on the performance with the new, structured content in the vault.",
        "testStrategy": "1. Add a new, detailed note about a specific technical topic (e.g., 'LoRA fine-tuning') to the Obsidian vault. 2. Verify that the new note is successfully synchronized and indexed by the Aletheia server's vector database. 3. Formulate a question that can only be answered by the content of the new note and submit it to the system. 4. Evaluate the RAG output for accuracy, relevance, and proper citation of the source note. 5. Periodically review the structure of the Obsidian vault to ensure it adheres to the established organizational best practices. 6. Assess the overall improvement in query responses as the knowledge base grows.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Research and collate articles/resources on 'second brain' methodologies (e.g., Zettelkasten, PARA).",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Document a standardized note-taking and linking strategy for the Aletheia project within the Obsidian vault.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Populate the vault with initial content related to AI development, RAG techniques, and project management best practices.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Test and refine the RAG process by querying the system with questions based on the newly added Obsidian content.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Create a feedback loop document within Obsidian to track query performance and areas for RAG improvement.",
            "status": "pending",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "Analyze Dockerfile and Verify Static Asset Collection",
        "description": "Investigate the Docker build process to confirm that the static assets, including the new Aletheia logos and webmanifest, are being correctly copied into the final image. This involves inspecting the Dockerfile and the file system of a running container.",
        "details": "1. **Inspect Dockerfile**: Look for the `COPY` or `ADD` instructions that handle the frontend build output (typically from a `build` or `out` directory) and other static assets. Verify the source and destination paths. Pay close attention to the `collectstatic` command. \n2. **Exec into Running Container**: Start the container and use `docker exec -it <container_id> /bin/sh` to get a shell. \n3. **Verify File Locations**: Navigate to the directory where static files are supposed to be collected (the `STATIC_ROOT` defined in Django's `settings.py`). Run `ls -l` to check for the existence of `Aletheia_logo.svg`, `Aletheia_logo_text.svg`, and `aletheia.webmanifest`. Check their file permissions to ensure they are readable by the user running the web server.",
        "testStrategy": "Successfully locate the logo and webmanifest files inside the running Docker container at the expected static root path using the `ls` command. File permissions should be at least `644` (readable by all).",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Review and Correct Django Static File Configuration",
        "description": "Review and correct Django's static file settings to ensure it's configured to serve the Next.js frontend's static assets from the `/static/` URL path. This is a likely cause of the `404` on `/static/aletheia.webmanifest`.",
        "details": "1. **Locate `settings.py`**: Find the main Django settings file.\n2. **Check `STATIC_URL`**: Ensure `STATIC_URL = '/static/'` is set.\n3. **Check `STATIC_ROOT`**: Ensure `STATIC_ROOT` is defined, e.g., `STATIC_ROOT = BASE_DIR / 'staticfiles'`.\n4. **Check `STATICFILES_DIRS`**: This is critical. It must include the path to the Next.js build output. Example: `STATICFILES_DIRS = [BASE_DIR / 'frontend/out']`.\n5. **Implement Whitenoise**: For robust static file serving in production, integrate the `whitenoise` library. Install it (`pip install whitenoise==6.6.0`). Add `'whitenoise.middleware.WhiteNoiseMiddleware'` to the top of the `MIDDLEWARE` list in `settings.py`, right after the `SecurityMiddleware`. Set `STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'`.",
        "testStrategy": "After configuration, the `collectstatic` command should run without errors and copy files from the Next.js build directory into the `STATIC_ROOT`. A request to a known static file (like the webmanifest) should succeed once the server is running.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Audit Frontend Codebase for Incorrect Asset Paths",
        "description": "The server logs show requests for logos without the `/static/` prefix. This strongly indicates that there are still hardcoded or incorrect paths in the frontend code. We need to find all such references.",
        "details": "1. **Target Files**: The issue is likely in the Next.js part of the codebase, specifically within `.tsx` or `.jsx` files.\n2. **Search the Codebase**: Run a project-wide search (using `grep` or your IDE's search function) for the literal strings 'Aletheia_logo.svg' and 'Aletheia_logo_text.svg'.\n3. **Identify Problem Areas**: The search will likely find `<img>` tags or component props with incorrect `src` attributes, like `src=\"/Aletheia_logo.svg\"` instead of `src=\"/static/Aletheia_logo.svg\"`.\n4. **Pay special attention to `khojLogo.tsx`**: Although it was mentioned as updated, it's the primary suspect. Double-check its logic.",
        "testStrategy": "Produce a list of all files and line numbers containing references to the logo files without the correct `/static/` prefix.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Fix Hardcoded Asset Paths in Next.js Frontend",
        "description": "Based on the audit, update all identified instances in the Next.js frontend to use the correct, dynamically-resolved paths for static assets, ensuring they are prefixed with `/static/`.",
        "details": "1. **Use Next.js `<Image>` component**: Where possible, refactor `<img>` tags to use Next.js's `<Image>` component, as it helps manage image optimization and paths. However, for SVG files, direct `<img>` tags are often simpler.\n2. **Correct `src` attributes**: Modify the incorrect paths found in the audit. The corrected path should be `src=\"/static/Aletheia_logo.svg\"`. \n3. **Pseudo-code Example**: \n   *Before*: `<img src=\"/Aletheia_logo.svg\" alt=\"Aletheia Logo\" />`\n   *After*: `<img src=\"/static/Aletheia_logo.svg\" alt=\"Aletheia Logo\" />`\n4. **Consider a base path helper**: If many paths need fixing, consider defining a constant for the static path to ensure consistency, e.g., `const STATIC_PATH = '/static';` and then use it like `src={\"`${STATIC_PATH}`/Aletheia_logo.svg\"}`.",
        "testStrategy": "After changes, run the Next.js build (`next build`). Inspect the generated HTML/JS files in the `out` directory to confirm that all references to the logo assets now correctly include the `/static/` prefix.",
        "priority": "medium",
        "dependencies": [
          18,
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Update Webmanifest and Favicon HTML Links",
        "description": "The `aletheia.webmanifest` file is returning a 404. This requires ensuring the `<link>` tag in the main HTML document head points to the correct static path.",
        "details": "1. **Locate the Head**: In Next.js, the main document head is typically managed in `src/pages/_document.tsx` or via the `next/head` component in `src/pages/_app.tsx`.\n2. **Inspect the `<link>` tag**: Find the `<link rel=\"manifest\" ...>` tag.\n3. **Correct the `href`**: The `href` attribute must point to the static path. Change `href=\"/aletheia.webmanifest\"` to `href=\"/static/aletheia.webmanifest\"`.\n4. **Check Favicon**: While there, check any associated favicon links (`<link rel=\"icon\" ...>`) for similar pathing issues and correct them as well.",
        "testStrategy": "Inspect the `<head>` of the rendered HTML page using browser developer tools to verify that the `href` attribute for the webmanifest link is correctly set to `/static/aletheia.webmanifest`.",
        "priority": "medium",
        "dependencies": [
          18,
          19
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Rebuild and Deploy Fixed Docker Image",
        "description": "After applying all code and configuration fixes, build a new Docker image and deploy it to a testing environment to prepare for final verification.",
        "details": "1. **Ensure Clean Build**: It's good practice to remove old images to avoid caching issues. Run `docker image prune` or specifically remove the old image tag.\n2. **Run Docker Build**: Execute the standard Docker build command for the project, e.g., `docker build -t aletheia-app:latest .`.\n3. **Tag and Push (if applicable)**: If using a registry, tag the image appropriately and push it.\n4. **Deploy the Container**: Stop and remove the old running container. Start a new container from the newly built image, ensuring all necessary ports and environment variables are correctly configured.",
        "testStrategy": "The Docker build command completes successfully. The `docker run` command starts the container without any immediate errors, and the application's server starts listening for requests.",
        "priority": "medium",
        "dependencies": [
          20,
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "End-to-End Verification and Log Monitoring",
        "description": "Perform a final, comprehensive check of the deployed application to ensure the logo and static asset issues are fully resolved and no new regressions have been introduced.",
        "details": "1. **Clear Browser Cache**: Use your browser's developer tools to perform a hard refresh and clear the cache to ensure you are not seeing stale content.\n2. **Load Application**: Navigate to the application's URL.\n3. **Visual Confirmation**: Visually confirm that the Aletheia logos are now displayed correctly.\n4. **Check DevTools Network Tab**: Open the Network tab in your browser's developer tools and reload the page. Filter for the asset names (`Aletheia_logo.svg`, `aletheia.webmanifest`) and confirm they return a `200 OK` status code.\n5. **Monitor Server Logs**: Check the live logs of the running container (`docker logs -f <container_id>`) to ensure no 404 errors related to these assets are being generated.",
        "testStrategy": "The application loads correctly with all logos visible. The browser's network tab shows `200 OK` for all static assets. The server logs are free of 404 errors for the specified files. This meets all success criteria.",
        "priority": "high",
        "dependencies": [
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Document the Solution for Future Reference",
        "description": "Document the root cause of the issue, the steps taken to fix it, and any new configurations (like Whitenoise) that were introduced. This will help prevent similar issues in the future.",
        "details": "1. **Create a Markdown File**: Create a new file, e.g., `docs/troubleshooting/static-asset-fix.md`.\n2. **Summarize the Problem**: Briefly describe the 404 errors on static assets after the rebranding.\n3. **Explain the Root Cause**: Detail the findings. This was likely a two-part problem: a) Incorrect, hardcoded paths in the Next.js frontend code, and b) Potentially incomplete Django static file configuration for serving the Next.js build output.\n4. **Outline the Solution**: List the key changes made, including: correcting paths in `.tsx` files, verifying `STATICFILES_DIRS` in `settings.py`, and implementing `whitenoise` for robust serving in production.\n5. **Commit to Repository**: Add the documentation file to the project's Git repository.",
        "testStrategy": "A markdown document is created and checked into the version control system, clearly explaining the problem and the solution for future reference by the development team.",
        "priority": "low",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Fix Traefik 'Bad Gateway' Error with Correct Docker Labels",
        "description": "Fix the Traefik 'Bad Gateway' error by adding missing router and SSL configuration labels to the server and n8n services in the docker-compose.production.yml file.",
        "details": "The `server` and `n8n` services are currently inaccessible, resulting in a \"Bad Gateway\" error because they lack the necessary Traefik labels for routing and SSL termination. This task involves updating the `docker-compose.production.yml` file to include these labels, using the working configuration from the original `khoj-ai/khoj` repository as a reference.\n\n**Implementation Steps:**\n1.  **Inspect `docker-compose.production.yml`**: Identify the `server` and `n8n` service definitions.\n2.  **Add Traefik Labels to `server` service**: Under the `labels` key for the `server` service, add the following:\n    - `traefik.enable=true`\n    - `traefik.http.routers.server.rule=Host('kodan.space')`\n    - `traefik.http.routers.server.entrypoints=websecure`\n    - `traefik.http.routers.server.tls.certresolver=myresolver`\n3.  **Add Traefik Labels to `n8n` service**: Under the `labels` key for the `n8n` service, add the following:\n    - `traefik.enable=true`\n    - `traefik.http.routers.n8n.rule=Host('n8n.kodan.space')`\n    - `traefik.http.routers.n8n.entrypoints=websecure`\n    - `traefik.http.routers.n8n.tls.certresolver=myresolver`\n4.  **Redeploy Services**: After saving the changes, run `docker-compose -f docker-compose.production.yml up -d` to apply the new configuration.",
        "testStrategy": "1.  **Deploy Changes**: Apply the updated `docker-compose.production.yml` to the production environment.\n2.  **Verify Server Access**: Navigate to `https://kodan.space` in a web browser. The application should load successfully without any \"Bad Gateway\" errors.\n3.  **Verify n8n Access**: Navigate to `https://n8n.kodan.space`. The n8n interface should load correctly.\n4.  **Check SSL Certificates**: Use browser developer tools to inspect the SSL certificate for both domains. Verify they are valid and issued by the correct authority (e.g., Let's Encrypt).\n5.  **Monitor Logs**: Check the Traefik container logs to ensure there are no errors related to certificate generation or routing for the `server` and `n8n` services.",
        "status": "done",
        "dependencies": [
          4,
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Containerize and Deploy Taskmaster MCP Server",
        "description": "Create a Dockerfile for the Taskmaster MCP server and add it as a new service to the `docker-compose.production.yml` file. This task will configure the server to run persistently on the VPS, providing a stable endpoint for the VS Code Kanban extension and other integrations.",
        "details": "1. **Create Dockerfile**: In the root directory of the Taskmaster MCP server, create a new file named `Dockerfile`.\n   - Use an appropriate Python base image (e.g., `python:3.10-slim`).\n   - Set a working directory (e.g., `WORKDIR /app`).\n   - Copy the `requirements.txt` file and install dependencies using `pip install --no-cache-dir -r requirements.txt`.\n   - Copy the rest of the server source code into the image.\n   - Expose the port the server runs on.\n   - Define the `CMD` to run the server.\n2. **Update Docker Compose**: Edit the `docker-compose.production.yml` file to include a new service for the MCP server.\n   - Define a service named `taskmaster-mcp`.\n   - Use the `build` instruction to point to the directory containing the new Dockerfile.\n   - Map the container's exposed port to a host port (e.g., `ports: [\"8001:8000\"]`).\n   - Set the restart policy to `unless-stopped` to ensure it runs persistently.\n3. **Deploy**: SSH into the VPS, pull the latest changes, and run `docker-compose -f docker-compose.production.yml up -d --build taskmaster-mcp` to build and start the new service.",
        "testStrategy": "1. **Verify Container Status**: After deployment, run `docker ps` on the VPS and confirm that the `taskmaster-mcp` container is running and has a status of 'Up'.\n2. **Inspect Logs**: Check the container's logs for any startup errors by running `docker logs <container_id_or_name>`. The logs should indicate that the server has started successfully.\n3. **Test Endpoint Connectivity**: Use a tool like `curl` to test the connection to the mapped host port (e.g., `curl http://<vps_ip>:8001/health`).\n4. **Client Integration Test**: Configure the VS Code Kanban extension to use the new server endpoint. Verify that the extension can successfully connect, fetch, and update tasks.",
        "status": "deferred",
        "dependencies": [
          1,
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Consolidate Development Logs into Changeset Workflow",
        "description": "Deprecate and remove redundant markdown devlog files. Establish the 'changeset' command, combined with Git history, as the single source of truth for tracking development progress and creating changelogs.",
        "details": "",
        "testStrategy": "",
        "status": "in-progress",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Develop an Intuitive n8n Management UI",
        "description": "Design and implement a user interface within the Aletheia web app to manage and visualize n8n workflows, as outlined in the project roadmap (RDM-005).",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Create a Browser Extension for Web RAG",
        "description": "Develop a Chrome browser extension for RAG capabilities on any webpage, allowing for summarization, analysis, and interaction with web content (RDM-006).",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement 'Visible Thinking Process' in UI",
        "description": "Implement a UI element that displays the AI's thought process (e.g., retrieved context, tool usage) before delivering the final response, to increase transparency (RDM-001).",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Create 'The Opinion Bank' Feature",
        "description": "Create a dedicated feature for users to log, track, and analyze their opinions on any topic, serving as a powerful self-improvement tool (RDM-014).",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Investigate and Implement Mobile Version of Aletheia",
        "description": "Research the existing mobile version of Aletheia (formerly Khoj). Determine if it's a native app, a PWA, or a responsive web design. Implement and test it to provide mobile access, prioritizing this over the enhanced Telegram integration.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "General UI/UX Overhaul for Aletheia",
        "description": "Perform a general overhaul of the Aletheia UI/UX. This includes implementing a visual context window indicator (e.g., a circle that fills up) to show users their current context usage, and other enhancements to improve user interaction and experience.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-15T11:57:48.051Z",
      "updated": "2025-08-21T07:24:04.085Z",
      "description": "Tasks for master context"
    }
  }
}